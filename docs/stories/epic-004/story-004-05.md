# Story 004-05: Generate graded pattern sizes

**Epic:** EPIC-004 - Professional Pattern Features
**Status:** Not Started
**Estimate:** 8 points
**Assigned To:** Unassigned

---

## Description

As a pattern designer, I want to generate all graded sizes from grading rules
so that I can produce patterns for entire size range.

---

## Acceptance Criteria

- [ ] User can trigger "Generate Graded Sizes" command
- [ ] System creates pattern copy for each size
- [ ] Grading rules are applied to adjust parameters
- [ ] Parametric system updates geometry for each size
- [ ] All sizes can be generated in < 5 seconds
- [ ] Preview shows all graded sizes overlaid or side-by-side
- [ ] Generated sizes are saved as separate patterns

---

## Technical Notes

**Grading Algorithm:**
```cpp
class GradingAlgorithm {
    GradingSystem* gradingSystem;
    Pattern* basePattern;

    std::vector<Pattern*> generateGradedSizes() {
        std::vector<Pattern*> gradedPatterns;

        for (const QString& size : gradingSystem->sizes) {
            if (size == gradingSystem->baseSize) {
                // Base size already exists
                gradedPatterns.push_back(basePattern);
                continue;
            }

            // Clone base pattern
            Pattern* gradedPattern = basePattern->clone();
            gradedPattern->setName(basePattern->name() + " - " + size);

            // Apply grading rules to parameters
            for (const GradeRule& rule : gradingSystem->rules) {
                double baseValue = gradedPattern->getParameter(rule.parameterName);
                double increment = rule.increments[size];
                double newValue = baseValue + increment;

                gradedPattern->setParameter(rule.parameterName, newValue);
            }

            // Update geometry via parametric system
            gradedPattern->updateGeometry();

            // Resolve constraints
            if (gradedPattern->hasConstraints()) {
                ConstraintSolver solver;
                solver.setConstraints(gradedPattern->getConstraints());
                solver.solve();
            }

            gradedPatterns.push_back(gradedPattern);
        }

        return gradedPatterns;
    }
};
```

**GradePatternCommand:**
```cpp
class GradePatternCommand : public Command {
    Pattern* basePattern;
    GradingSystem* gradingSystem;
    std::vector<Pattern*> generatedPatterns;

    void execute() override {
        GradingAlgorithm algorithm;
        algorithm.setGradingSystem(gradingSystem);
        algorithm.setBasePattern(basePattern);

        generatedPatterns = algorithm.generateGradedSizes();

        // Add all generated patterns to project
        for (Pattern* pattern : generatedPatterns) {
            project->addPattern(pattern);
        }
    }

    void undo() override {
        // Remove generated patterns from project
        for (Pattern* pattern : generatedPatterns) {
            if (pattern != basePattern) {
                project->removePattern(pattern);
            }
        }
    }
};
```

**Preview UI:**
- Show all graded sizes overlaid (different colors)
- Option to view side-by-side in grid
- Show size labels for each pattern

**Performance:**
- Target: < 5 seconds for typical patterns
- Profile bottlenecks: geometry update, constraint solving
- Consider parallel generation using QtConcurrent

---

## Dependencies

- story-004-04: Define size grading rules
- story-002-04: Update geometry when parameters change

---

## Definition of Done

- [ ] GradingAlgorithm implemented
- [ ] GradePatternCommand implemented
- [ ] Pattern cloning with all features
- [ ] Parameter adjustment working
- [ ] Geometry update working
- [ ] Constraint solving for each size
- [ ] Preview UI showing all sizes
- [ ] Performance target met (< 5 seconds)
- [ ] Unit tests for grading algorithm
- [ ] Integration tests
- [ ] Documentation updated
- [ ] Merged to main branch
