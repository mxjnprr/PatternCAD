# Story 002-03: Build parameter dependency graph

**Epic:** EPIC-002 - Parametric Design and Constraint System
**Status:** Not Started
**Estimate:** 8 points
**Assigned To:** Unassigned

---

## Description

As a developer, I need to track parameter dependencies in a directed graph
so that parameter updates propagate correctly to dependent parameters and geometry.

---

## Acceptance Criteria

- [ ] System builds dependency graph from parameter expressions
- [ ] Graph tracks which parameters depend on which (directed edges)
- [ ] Graph detects circular dependencies and reports clear error
- [ ] Topological sort determines correct update order
- [ ] Graph updates incrementally when parameters added/removed/changed
- [ ] Performance: graph operations < 10ms for 200 parameters

---

## Technical Notes

**Dependency Graph Structure:**
```cpp
class DependencyGraph {
    // Adjacency list: param -> list of params that depend on it
    QMap<QString, QSet<QString>> adjacencyList;

public:
    void addDependency(const QString& from, const QString& to);
    void removeDependency(const QString& from, const QString& to);
    void removeNode(const QString& param);

    bool hasCycle() const;  // Detect circular dependencies
    QStringList findCycle() const;  // Return cycle path if exists

    QList<QString> topologicalSort() const;  // Update order
    QSet<QString> getDependents(const QString& param) const;
};
```

**Circular Dependency Detection:**
- Use DFS with recursion stack
- Track visited nodes and current path
- If revisit node in current path â†’ cycle detected

**Algorithm:**
```cpp
bool hasCycleUtil(const QString& node,
                  QSet<QString>& visited,
                  QSet<QString>& recStack) {
    visited.insert(node);
    recStack.insert(node);

    for (const QString& neighbor : adjacencyList[node]) {
        if (!visited.contains(neighbor)) {
            if (hasCycleUtil(neighbor, visited, recStack))
                return true;
        } else if (recStack.contains(neighbor)) {
            return true;  // Cycle detected
        }
    }

    recStack.remove(node);
    return false;
}
```

**Topological Sort:**
- Use Kahn's algorithm (queue-based BFS)
- Or DFS-based with post-order traversal

---

## Dependencies

- story-002-02: Expression parser to extract dependencies

---

## Definition of Done

- [ ] DependencyGraph class implemented
- [ ] Circular dependency detection working
- [ ] Topological sort working
- [ ] Comprehensive unit tests (cycles, sorting, edge cases)
- [ ] Performance tested with 200 parameters
- [ ] Documentation with examples
- [ ] Merged to main branch
