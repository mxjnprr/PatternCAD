# Story 002-08: Implement geometric constraint solver

**Epic:** EPIC-002 - Parametric Design and Constraint System
**Status:** Not Started
**Estimate:** 13 points
**Assigned To:** Unassigned

---

## Description

As a developer, I need a constraint solver that adjusts geometry to satisfy constraints
so that parametric patterns maintain their geometric relationships.

**⚠️ HIGH COMPLEXITY:** This is the most technically complex story in the project.

---

## Acceptance Criteria

- [ ] Solver uses Newton-Raphson iterative method as primary algorithm
- [ ] Solver builds error vector from all constraint violations
- [ ] Solver computes Jacobian (derivatives) matrix numerically
- [ ] Solver adjusts geometry to minimize error (converges to solution)
- [ ] Solver converges in < 200ms for typical constraint networks (10-20 constraints)
- [ ] Solver handles non-convergence gracefully (gradient descent fallback)
- [ ] Solver detects over-constrained systems (rank-deficient Jacobian)
- [ ] Solver detects under-constrained systems (degrees of freedom remain)
- [ ] Performance: handles 50 constraints in < 500ms

---

## Technical Notes

**ConstraintSolver Class:**
```cpp
class ConstraintSolver {
    std::vector<Constraint*> constraints;
    std::vector<GeometryObject*> variables;  // Objects being adjusted

public:
    enum Result { Converged, NotConverged, OverConstrained };

    Result solve(int maxIterations = 100, double tolerance = 1e-6);

private:
    Eigen::VectorXd buildErrorVector();
    Eigen::MatrixXd computeJacobian(double epsilon = 1e-8);
    void updateGeometry(const Eigen::VectorXd& delta);
    double computeTotalError();

    Result newtonRaphson(int maxIter, double tol);
    Result gradientDescent(int maxIter, double tol);  // Fallback
};
```

**Newton-Raphson Algorithm:**
```
1. Initialize: x₀ = current geometry state
2. Repeat until converged or max iterations:
   a. Compute error vector: e = [c₁(x), c₂(x), ..., cₙ(x)]
   b. Compute Jacobian: J = ∂e/∂x (numerical derivatives)
   c. Solve linear system: J·Δx = -e
   d. Update: x = x + Δx
   e. If ||e|| < tolerance: converged
3. Apply final geometry state
```

**Jacobian Computation (Finite Differences):**
```cpp
Eigen::MatrixXd computeJacobian(double epsilon) {
    int m = constraints.size();
    int n = getDegreesOfFreedom();
    Eigen::MatrixXd J(m, n);

    for (int j = 0; j < n; j++) {
        // Perturb variable j by epsilon
        double originalValue = getVariable(j);
        setVariable(j, originalValue + epsilon);

        Eigen::VectorXd e_plus = buildErrorVector();

        setVariable(j, originalValue);  // Restore
        Eigen::VectorXd e = buildErrorVector();

        // Compute derivative: de/dx ≈ (e(x+ε) - e(x)) / ε
        J.col(j) = (e_plus - e) / epsilon;
    }

    return J;
}
```

**Linear System Solver:**
- Use Eigen library: `J.colPivHouseholderQr().solve(-error)`
- Check for rank deficiency (over-constrained)
- Use SVD decomposition for robustness

**Gradient Descent Fallback:**
```cpp
Result gradientDescent(int maxIter, double tol) {
    double learningRate = 0.1;
    for (int iter = 0; iter < maxIter; iter++) {
        Eigen::VectorXd e = buildErrorVector();
        if (e.norm() < tol) return Converged;

        // Compute gradient (Jacobian transpose × error)
        Eigen::MatrixXd J = computeJacobian();
        Eigen::VectorXd grad = J.transpose() * e;

        // Step in negative gradient direction
        Eigen::VectorXd delta = -learningRate * grad;
        updateGeometry(delta);
    }
    return NotConverged;
}
```

**Performance Optimization:**
- Cache Jacobian if constraints haven't changed
- Use sparse matrices for large systems
- Parallel constraint evaluation (OpenMP)
- Early termination if error small enough

**Testing Strategy:**
- Unit tests with simple constraints (2 points, fixed distance)
- Test convergence for various configurations
- Test non-convergence detection
- Test over-constrained detection (conflicting constraints)
- Performance benchmarks

---

## Dependencies

- story-002-05, 006, 007: All constraint types implemented
- Eigen library for linear algebra

---

## Definition of Done

- [ ] ConstraintSolver fully implemented
- [ ] Newton-Raphson algorithm working
- [ ] Gradient descent fallback working
- [ ] Over/under-constrained detection
- [ ] Performance targets met (< 200ms typical)
- [ ] Comprehensive unit tests (20+ test cases)
- [ ] Integration tests with real geometry
- [ ] Performance benchmarks documented
- [ ] Algorithm documentation written
- [ ] Merged to main branch
