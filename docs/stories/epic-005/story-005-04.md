# Story 005-04: Automatic nesting with greedy algorithm

**Epic:** EPIC-005 - Layout, Nesting, and Isolation
**Status:** Not Started
**Estimate:** 13 points
**Assigned To:** Unassigned

---

## Description

As a pattern designer, I want to automatically nest pattern pieces on material
so that I can minimize material waste.

---

## Acceptance Criteria

- [ ] User can trigger "Auto Nest" command
- [ ] User can specify material dimensions
- [ ] User can specify minimum spacing/gap between pieces
- [ ] User can define grain direction constraints per piece
- [ ] User can lock rotation or allow specific rotations (0°, 90°, 180°, 270°)
- [ ] Greedy nesting algorithm runs in < 10 seconds for 20-50 pieces
- [ ] System displays material utilization percentage
- [ ] Result can be manually adjusted after nesting
- [ ] Nesting is undoable

---

## Technical Notes

**Nesting Algorithm (Greedy Bottom-Left):**
```cpp
class NestingAlgorithm {
    std::vector<Pattern*> patterns;
    QRectF materialBounds;
    double minSpacing;
    std::map<Pattern*, RotationConstraint> rotationConstraints;

    struct PlacementResult {
        std::map<Pattern*, Transform> placements;
        double utilization;
    };

    PlacementResult nest() {
        // 1. Sort patterns by area (largest first)
        std::vector<Pattern*> sortedPatterns = patterns;
        std::sort(sortedPatterns.begin(), sortedPatterns.end(),
                 [](Pattern* a, Pattern* b) {
                     return a->area() > b->area();
                 });

        // 2. Place patterns one by one
        std::vector<QRectF> occupiedRegions;
        PlacementResult result;

        for (Pattern* pattern : sortedPatterns) {
            // Try all allowed rotations
            Transform bestPlacement;
            double bestY = std::numeric_limits<double>::max();

            for (double rotation : getAllowedRotations(pattern)) {
                Pattern* rotated = pattern->clone();
                rotated->rotate(rotation);

                // Try to find valid position (bottom-left heuristic)
                for (double x = 0; x <= materialBounds.width(); x += 1.0) {
                    double y = findLowestValidY(rotated, x, occupiedRegions);

                    if (y < bestY && isWithinBounds(rotated, x, y)) {
                        bestY = y;
                        bestPlacement = Transform(x, y, rotation);
                    }
                }

                delete rotated;
            }

            if (bestY < std::numeric_limits<double>::max()) {
                result.placements[pattern] = bestPlacement;
                occupiedRegions.push_back(
                    getOccupiedRegion(pattern, bestPlacement, minSpacing)
                );
            } else {
                // Pattern doesn't fit - leave unplaced
                qWarning() << "Pattern" << pattern->name() << "doesn't fit";
            }
        }

        // 3. Calculate utilization
        result.utilization = calculateUtilization(result.placements);

        return result;
    }

    double findLowestValidY(Pattern* pattern, double x,
                           const std::vector<QRectF>& occupied) {
        double y = 0;

        // Check collisions with all occupied regions
        QRectF patternBounds = pattern->boundingRect();
        patternBounds.translate(x, y);

        for (const QRectF& region : occupied) {
            if (patternBounds.intersects(region)) {
                // Move pattern above this region
                y = region.bottom();
                patternBounds.translate(0, y - patternBounds.top());
            }
        }

        return y;
    }
};
```

**NestPiecesCommand:**
```cpp
class NestPiecesCommand : public Command {
    std::vector<Pattern*> patterns;
    std::map<Pattern*, Transform> originalTransforms;
    std::map<Pattern*, Transform> nestedTransforms;

    void execute() override {
        // Save original transforms
        for (Pattern* pattern : patterns) {
            originalTransforms[pattern] = pattern->transform();
        }

        // Run nesting algorithm (in background thread)
        NestingAlgorithm algorithm;
        algorithm.setPatterns(patterns);
        algorithm.setMaterialBounds(materialBounds);
        algorithm.setMinSpacing(minSpacing);

        auto result = algorithm.nest();
        nestedTransforms = result.placements;

        // Apply nested transforms
        for (auto& [pattern, transform] : nestedTransforms) {
            pattern->setTransform(transform);
        }

        // Display utilization
        showUtilization(result.utilization);
    }
};
```

**Auto Nest Dialog:**
```
┌─ Auto Nest ────────────────────────────────┐
│ Material:                                   │
│   Width:  [1500] mm                        │
│   Height: [1000] mm                        │
│                                             │
│ Spacing:                                    │
│   Minimum gap: [5] mm                      │
│                                             │
│ Rotation:                                   │
│   [x] Allow 90° rotation                   │
│   [x] Allow 180° rotation                  │
│   [ ] Allow 270° rotation                  │
│   [ ] Allow free rotation                  │
│                                             │
│ [Nest] [Cancel]                            │
└─────────────────────────────────────────────┘
```

**Performance:**
- Run in QThread to avoid blocking UI
- Show progress bar for long operations
- Target: < 10 seconds for 50 pieces

---

## Dependencies

- story-005-02: Manual placement

---

## Definition of Done

- [ ] NestingAlgorithm implemented (greedy bottom-left)
- [ ] Rotation constraints working
- [ ] Grain direction constraints (optional)
- [ ] Minimum spacing enforced
- [ ] NestPiecesCommand implemented
- [ ] Auto Nest dialog implemented
- [ ] Performance target met (< 10 seconds)
- [ ] Utilization calculation and display
- [ ] Manual adjustment after nesting possible
- [ ] Undo/redo working
- [ ] Unit tests for nesting algorithm
- [ ] Integration tests
- [ ] Documentation updated
- [ ] Merged to main branch
