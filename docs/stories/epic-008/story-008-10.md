# Story 008-10: Grid overlay and snap-to-grid

**Epic:** EPIC-008 - User Interface and Cross-Platform Foundation
**Status:** Not Started
**Estimate:** 5 points
**Assigned To:** Unassigned

---

## Description

As a pattern designer, I want optional grid overlay and snap-to-grid
so that I can align objects precisely.

---

## Acceptance Criteria

- [ ] Grid overlay can be toggled on/off (G key or View menu)
- [ ] Grid spacing is configurable in preferences (default: 10mm)
- [ ] Grid appears as dots or lines (user preference)
- [ ] Grid auto-scales based on zoom level (larger spacing at low zoom)
- [ ] Snap-to-grid can be toggled (Ctrl+Shift+G)
- [ ] When snap enabled, objects snap to grid during move/create
- [ ] Grid and snap settings are saved in project

---

## Technical Notes

**Implementation Details:**
- Implement grid rendering in QGraphicsScene
- Add grid QGraphicsItem (draws grid pattern)
- Implement snap logic in move and create operations
- Add grid preferences to settings
- Auto-scale grid based on zoom

**Grid Renderer:**
```cpp
class GridItem : public QGraphicsItem {
public:
    GridItem();

    void setGridSpacing(double spacing);
    void setGridStyle(GridStyle style);  // Dots or Lines
    void setGridColor(const QColor& color);
    void setVisible(bool visible);

    QRectF boundingRect() const override;
    void paint(QPainter* painter,
               const QStyleOptionGraphicsItem* option,
               QWidget* widget) override;

private:
    double gridSpacing_;
    GridStyle gridStyle_;
    QColor gridColor_;

    void paintDotGrid(QPainter* painter, const QRectF& rect);
    void paintLineGrid(QPainter* painter, const QRectF& rect);
    double getVisibleSpacing(double zoom) const;
};

enum class GridStyle {
    Dots,
    Lines
};
```

**Grid Settings:**
```cpp
struct GridSettings {
    bool enabled = false;
    double spacing = 10.0;  // mm
    GridStyle style = GridStyle::Dots;
    QColor color = QColor(200, 200, 200, 128);  // Light gray, semi-transparent

    // Auto-scaling
    bool autoScale = true;
    double minVisibleSpacing = 5.0;   // pixels
    double maxVisibleSpacing = 50.0;  // pixels

    QJsonObject toJson() const;
    static GridSettings fromJson(const QJsonObject& json);
};
```

**Grid Rendering Implementation:**

### Dot Grid
```cpp
void GridItem::paintDotGrid(QPainter* painter, const QRectF& rect) {
    double spacing = getVisibleSpacing(currentZoom_);

    painter->setPen(Qt::NoPen);
    painter->setBrush(gridColor_);

    double startX = std::floor(rect.left() / spacing) * spacing;
    double startY = std::floor(rect.top() / spacing) * spacing;

    for (double x = startX; x <= rect.right(); x += spacing) {
        for (double y = startY; y <= rect.bottom(); y += spacing) {
            painter->drawEllipse(QPointF(x, y), 1.0, 1.0);
        }
    }
}
```

### Line Grid
```cpp
void GridItem::paintLineGrid(QPainter* painter, const QRectF& rect) {
    double spacing = getVisibleSpacing(currentZoom_);

    painter->setPen(QPen(gridColor_, 1.0));

    double startX = std::floor(rect.left() / spacing) * spacing;
    double startY = std::floor(rect.top() / spacing) * spacing;

    // Vertical lines
    for (double x = startX; x <= rect.right(); x += spacing) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }

    // Horizontal lines
    for (double y = startY; y <= rect.bottom(); y += spacing) {
        painter->drawLine(QPointF(rect.left(), y), QPointF(rect.right(), y));
    }
}
```

**Auto-scaling:**
```cpp
double GridItem::getVisibleSpacing(double zoom) const {
    if (!gridSettings_.autoScale) {
        return gridSettings_.spacing;
    }

    double screenSpacing = gridSettings_.spacing * zoom;

    // If spacing too small, increase by powers of 2
    while (screenSpacing < gridSettings_.minVisibleSpacing) {
        screenSpacing *= 2.0;
    }

    // If spacing too large, decrease by powers of 2
    while (screenSpacing > gridSettings_.maxVisibleSpacing) {
        screenSpacing /= 2.0;
    }

    return screenSpacing / zoom;
}
```

**Snap-to-Grid:**
```cpp
class SnapManager {
public:
    SnapManager();

    void setSnapEnabled(bool enabled);
    void setSnapToGrid(bool enabled);
    void setSnapToObjects(bool enabled);
    void setSnapDistance(double distance);
    void setGridSpacing(double spacing);

    QPointF snapPoint(const QPointF& point) const;

private:
    bool snapEnabled_;
    bool snapToGrid_;
    bool snapToObjects_;
    double snapDistance_;
    double gridSpacing_;

    QPointF snapToGridPoint(const QPointF& point) const;
    QPointF snapToNearbyObjects(const QPointF& point) const;
};
```

**Grid Snapping Implementation:**
```cpp
QPointF SnapManager::snapToGridPoint(const QPointF& point) const {
    if (!snapEnabled_ || !snapToGrid_) {
        return point;
    }

    double x = std::round(point.x() / gridSpacing_) * gridSpacing_;
    double y = std::round(point.y() / gridSpacing_) * gridSpacing_;

    return QPointF(x, y);
}

QPointF SnapManager::snapPoint(const QPointF& point) const {
    if (!snapEnabled_) {
        return point;
    }

    QPointF snapped = point;

    // Try grid snap first
    if (snapToGrid_) {
        snapped = snapToGridPoint(point);
    }

    // Then try object snap (smart guides)
    if (snapToObjects_) {
        QPointF objectSnap = snapToNearbyObjects(point);
        if (!objectSnap.isNull()) {
            // Use object snap if it's closer
            if (QLineF(point, objectSnap).length() <
                QLineF(point, snapped).length()) {
                snapped = objectSnap;
            }
        }
    }

    return snapped;
}
```

**Integration with Tools:**
```cpp
// In drawing and move tools
QPointF Tool::getSnappedPoint(const QPointF& point) const {
    return canvas_->snapManager()->snapPoint(point);
}

// Example: Line tool
void LineTool::mouseMoveEvent(QMouseEvent* event) {
    QPointF scenePos = canvas_->mapToScene(event->pos());
    QPointF snappedPos = getSnappedPoint(scenePos);

    if (isDrawing_) {
        previewLine_->setEndPoint(snappedPos);
    }

    // Show snap indicator
    if (snappedPos != scenePos) {
        canvas_->showSnapIndicator(snappedPos);
    }
}
```

**Snap Indicator:**
```cpp
class SnapIndicator : public QGraphicsItem {
public:
    void show(const QPointF& pos) {
        setPos(pos);
        setVisible(true);
        QTimer::singleShot(500, [this]() { setVisible(false); });
    }

    void paint(QPainter* painter,
               const QStyleOptionGraphicsItem* option,
               QWidget* widget) override {
        // Draw small crosshair or circle
        painter->setPen(QPen(Qt::green, 2.0));
        painter->drawEllipse(QPointF(0, 0), 5, 5);
    }

    QRectF boundingRect() const override {
        return QRectF(-5, -5, 10, 10);
    }
};
```

**Grid Manager:**
```cpp
class GridManager {
public:
    GridManager(QGraphicsScene* scene);

    void setGridEnabled(bool enabled);
    void setGridSettings(const GridSettings& settings);
    GridSettings getGridSettings() const;

    void toggleGrid();
    void toggleSnap();

    bool isGridVisible() const;
    bool isSnapEnabled() const;

signals:
    void gridVisibilityChanged(bool visible);
    void snapEnabledChanged(bool enabled);

private:
    QGraphicsScene* scene_;
    GridItem* gridItem_;
    GridSettings settings_;
};
```

**Keyboard Shortcuts:**
- **G:** Toggle grid visibility
- **Ctrl+Shift+G:** Toggle snap-to-grid
- Status bar shows: "Grid: ON (10mm)" or "Grid: OFF"
- Status bar shows: "Snap: ON" or "Snap: OFF"

**Preferences Dialog:**
```cpp
// In preferences dialog
QGroupBox* createGridPreferences() {
    auto* group = new QGroupBox("Grid Settings");
    auto* layout = new QFormLayout(group);

    auto* spacingSpinBox = new QDoubleSpinBox();
    spacingSpinBox->setRange(1.0, 100.0);
    spacingSpinBox->setValue(10.0);
    spacingSpinBox->setSuffix(" mm");

    auto* styleCombo = new QComboBox();
    styleCombo->addItems({"Dots", "Lines"});

    auto* autoScaleCheck = new QCheckBox("Auto-scale with zoom");
    autoScaleCheck->setChecked(true);

    layout->addRow("Grid Spacing:", spacingSpinBox);
    layout->addRow("Grid Style:", styleCombo);
    layout->addRow("", autoScaleCheck);

    return group;
}
```

---

## Dependencies

- story-008-02 (Canvas must exist)

---

## Definition of Done

- [ ] Code implemented and committed
- [ ] Unit tests written and passing
- [ ] Integration tests passing
- [ ] Code reviewed and approved
- [ ] Documentation updated
- [ ] Manual testing completed
- [ ] No critical or high-priority bugs
- [ ] Acceptance criteria verified
- [ ] Grid rendering performant at all zoom levels
- [ ] Snap-to-grid working in all tools
- [ ] Settings persist across sessions
- [ ] Auto-scaling works correctly
